<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>streams, node.js and you</h2>
          <p><small><a href="http://nodejs.org/docs/latest/api/stream.html">http://nodejs.org/docs/latest/api/stream.html</a></small></p>
          <p><small><a href="https://github.com/bnoordhuis">https://github.com/bnoordhuis</a></small></p>
          <p><small><a href="mailto:ben@strongloop.com">ben@strongloop.com</a></small></p>
        </section>

        <section>
          <h2>what are streams?</h2>
          <p>like UNIX pipes</p>
          <p><pre>
          $ cut -f 1 | sort | uniq -c | sort -n | tac
          </pre></p>
          <p><pre><code>
          process.stdin.pipe(new Cut({ field: 1 }))
                       .pipe(new Sort)
                       .pipe(new Uniq({ count: true })
                       .pipe(new Sort({ numeric: true })
                       .pipe(new Reverse);
          </code></pre></p>
          <aside class="notes">
          tac (reversed cat) is a GNU coreutils thing, can be replaced
          with sort -r
          </aside>
        </section>

        <section>
          <h2>concepts</h2>
          <p>
            <ul>
              <li>sources and sinks</li>
              <li>ordered</li>
              <li>reliable</li>
              <li>push model</li>
              <li>handle backpressure</li>
            </ul>
          </p>
          <aside class="notes">
          ordered: FIFO, no reordering
          reliable: no dropped segments
          push model: source notifies sink, not other way around
          handle backpressure: don't block on slow producers, don't buffer
                               on slow consumers
          </aside>
        </section>

        <section>
          <h2>basic usage example</h2>
          <p><pre><code>
          // message of the day service (tcp)
          function motd(conn) {
            require('fs').createReadStream('/etc/motd').pipe(conn);
          }
          require('net').createServer(motd).listen(8000);
          </code></pre></p>
          <p><pre>
          $ nc 127.0.0.1 8000
          All systems nominal.
          </pre></p>
          <aside class="notes">
          handles backpressure automagically
          </aside>
        </section>

        <section>
          <h2>basic usage example</h2>
          <p><pre><code>
          // message of the day service (http)
          function motd(req, res) {
            require('fs').createReadStream('/etc/motd').pipe(res);
          }
          require('http').createServer(motd).listen(8000);
          </code></pre></p>
          <p><pre>
          $ curl -s http://127.0.0.1:8000/
          All systems nominal.
          </pre></p>
          <aside class="notes">
          sends chunked encoding response
          </aside>
        </section>

        <section>
          <h2>basic usage example</h2>
          <p><pre><code>
          // chat service for narcissists
          function echo(conn) {
            conn.pipe(conn);
          }
          require('net').createServer(echo).listen(8000);
          </code></pre></p>
          <p><pre>
          $ nc 127.0.0.1 8000
          ping?
          ping?
          ^C
          </pre></p>
        </section>

        <section>
          <h2>basic usage example</h2>
          <p><pre><code>
          // an online REPL
          function repl(conn) {
            require('repl').start({ input: conn, output: conn });
          }
          require('net').createServer(repl).listen(8000);
          </code></pre></p>
          <p><pre>
          $ nc 127.0.0.1 8000
          &gt; 1+1
          2
          &gt; ^C
          </pre></p>
        </section>

        <section>
          <h2>basic usage example</h2>
          <p><pre><code>
          // encryption service
          function encrypt(req, res) {
            var args = req.url.split('/').slice(1, 3);
            var algo = args[0], secret = args[1];
            var cipher = require('crypto').createCipher(algo, secret);
            req.pipe(cipher).pipe(res);
          }
          require('http').createServer(encrypt).listen(8000);
          </code></pre></p>
          <p><pre>
          $ curl -d 'PRISM this!' localhost:8000/aes192/secret | xxd -c8
          0000000: 43e9 36bd 2b46 c553  C.6.+F.S
          0000008: dca5 bd7f e6ae af00  ........
          </pre></p>
        </section>

        <section>
          <h2>the bad old days</h2>
          <p>streams in v0.8 (oldstable, maintenance)</p>
          <p>
            <ul>
              <li>
              pro: easy to implement<br>
<pre><code>var events = require('events');
function MyStream() {
  this.__proto__ = new events.EventEmitter;
  this.write = function(data) { /* ... */ };
  this.end = function() { /* ... */ };
}
</code></pre>
              </li>
              <li class="fragment">con: easy to implement wrong</li>
              <li class="fragment">
                con: leaves much at implementer's discretion<br>
                &nbsp;&nbsp;e.g. stream.pause() is optional
              </li>
            </ul>
          </p>
          <aside class="notes">
          easy to implement wrong: lots of implicit contract
          </aside>
        </section>

        <section>
          <h2>happy days are here again</h2>
          <p>streams in v0.10 (stable, current)</p>
          <p>
            <ul>
              <li>pro: easy to implement</li>
              <li class="fragment">
                con: some v0.8 code no longer works
<pre><code>// broken, stream is not started
function broken(conn) {
  conn.on('end', function() {
    conn.end('Bye.');
  });
  // conn.resume();
}
require('net').createServer(broken)
              .listen(8000);
</code></pre>
                resume() force-starts stream
              </li>
            </ul>
          </p>
        </section>

        <section>
          <h2>stream types</h2>
          <p>
            <ul>
              <li>Readable (data source)</li>
              <li>Writable (data sink)</li>
              <li>Duplex (both)</li>
              <li>Transformer (both)</li>
            </ul>
          </p>
        </section>

        <section>
          <h2>Readable</h2>
          <p><pre><code>
          var Readable = require('stream').Readable;
          var words = require('fs')
            .readFileSync('/usr/share/dict/words', 'utf8')
            .split('\n');

          // generates `n` random words
          function RandomWordStream(n) {
            this.__proto__ = Readable.call(this);
            this._read = function(size) {
              if (n-- === 0) return this.push(null);  // EOF
              var index = Math.random() * words.length | 0;
              this.push(words[index]);
            };
          }

          (new RandomWordStream(8)).pipe(process.stdout);
          </code></pre></p>
        </section>

        <section>
          <h2>Readable</h2>
          <ul>
            <li>only have to implement _read()</li>
            <li>size hint is optional</li>
            <li>push chunks to data sink</li>
          </ul>
        </section>

        <section>
          <h2>Writable</h2>
          <p><pre><code>
          // splice data into two target streams
          function SpliceStream() {
            this.__proto__ = Writable.call(this);
            this._write = function(chunk, encoding, done) {
              process.stdout.write(chunk);
              process.stderr.write(chunk);
              done();
            };
          }
          process.stdin.pipe(new SpliceStream);
          </code></pre></p>
          <p><pre><code>
          // silly example, verbose way of doing:
          process.stdin.pipe(process.stdout);
          process.stdin.pipe(process.stderr);
          </code></pre></p>
        </section>

        <section>
          <h2>Writable</h2>
          <p><pre><code>
          // not to mention wrong, doesn't handle backpressure
          // _write() should look something like this
          this._write = function(chunk, encoding, done) {
            var n = 0;
            function cb() {
              if (++n === 2) done();
            }
            process.stdout.write(chunk, cb);
            process.stderr.write(chunk, cb);
          };
          </code></pre></p>
        </section>

        <section>
          <h2>Writable</h2>
          <ul>
            <li>only have to implement _write()</li>
            <li>encoding is always 'buffer' unless decodeStrings=false</li>
            <li>call done() when you're done</li>
          </ul>
          <aside class="notes">
          done can be invoked asynchronously
          </aside>
        </section>

        <section>
          <h2>Duplex</h2>
          <p>is-a Readable and a Writable, nothing more.</p>
        </section>

        <section>
          <h2>Transformer</h2>
          <p><pre><code>
          var Transform = require('stream').Transform;

          function CapsLockStream() {
            this.__proto__ = Transform.call(this);
            this._transform = function(data, encoding, done) {
              for (var i = 0; i &lt; data.length; i++)
                if (data[i] &gt;= 97 &amp;&amp; data[i] &lt;= 122)
                  data[i] &amp;= ~32;
              this.push(data);
              done();
            };
          }

          process.stdin.pipe(new CapsLockStream)
                       .pipe(process.stdout);
          </code></pre></p>
        </section>

        <section>
          <h2>Transformer</h2>
          <ul>
            <li>only have to implement _transform()</li>
            <li>can optionall implement _flush()</li>
          </ul>
          <aside class="notes">_flush() is for emitting trailing data</aside>
        </section>

        <section>
          <h1>questions?</h1>
        </section>

        <section>
          <h2>time permitting...</h2>
        </section>

        <section>
          <h2>and apropos nothing...</h2>
        </section>

        <section>
          <h2>Math.floor(x / 3) considered harmful</h2>
          <p>or:</p>
          <h3>friends don't let friends divide by 3</h3>
        </section>

        <section>
          <p>
<pre><code>// div3.js
function f(x) {
  return Math.floor(x / 3);
}
f(10);
%OptimizeFunctionOnNextCall(f);
f(10);
D.Debug.disassemble(f);
</code></pre>
          </p>
          <p>
<pre>$ out/x64.debug/d8 --allow-natives-syntax --expose-debug-as=D \
                     div3.js 2&gt;&amp;1 | grep -C2 idivl
</pre>
<pre>
0x29a7c2845d9b    59  b903000000     movl rcx,0x3
0x29a7c2845da0    64  99             cdq
<span style="color:red">0x29a7c2845da1    65  f7f9           idivl rcx  // OH NOES!</span>
0x29a7c2845da3    67  85d2           testl rdx,rdx
0x29a7c2845da5    69  0f856d000000   jnz 184  (0x29a7c2845e18)</pre>
          </p>
        </section>

      <section>
        <h3>idiv is expensive!</h3>
        <p class="fragment">takes between 26 and <strong>191</strong> CPU cycles</p>
        <p class="fragment">most instructions only take 1-3 cycles</p>
        <p class="fragment">easily most expensive instruction in everyday use</p>
      </section>

      <section>
        <h3>magic constants to the rescue!</h3>
        <pre><code>function div3(x) { return (x * 0x5556) &gt;&gt; 16 }</code></pre>
        <ul>
          <li class="fragment">mul is fast, 1-18 cycles</li>
          <li class="fragment">
            pro: works for both signed and unsigned division
<pre><code>div3(100);   // 33
div3(-100);  // -34</code></pre>
          </li>
          <li class="fragment">
            con: doesn't work for large numbers
<pre><code>Math.floor(0x1337BABE / 3);    // 107473130
(0x1337BABE * 0x5556) &gt;&gt;&gt; 16;  // 62905</code></pre>
            only accurate for numbers between -32768 and 32767
          </li>
        </ul>
      </section>

      <section>
        <h3>the shifty approach adds up</h3>
<pre><code>
function div3(x) {
  var t = x &gt;&gt;&gt; 2;
  t += t &gt;&gt;&gt; 2;
  t += t &gt;&gt;&gt; 4;
  t += t &gt;&gt;&gt; 8;
  t += t &gt;&gt;&gt; 16;
  x -= t + t + t;
  x += (x &lt;&lt; 3) + (x &lt;&lt; 1);
  t += x &gt;&gt;&gt; 5;
  return t;
}
</code></pre>
        <ul>
          <li class="fragment">pro: fast, only shifts, adds and one sub</li>
          <li class="fragment">pro: works for both signed and unsigned division</li>
          <li class="fragment">pro: works for large numbers (-2147483648 to 2147483647)</li>
        </ul>
        <aside class="notes">only ~20 cycles, discounting v8 overhead</aside>
      </section>

      <section>
        <h3>conclusion</h3>
        <ul>
          <li>division by fixed divisor is expensive</li>
          <li>can always be reduced to add/sub/shift sequences</li>
          <li>for integers within range -2^31 to 2^31-1</li>
        </ul>
      </section>

      <section>
        <h1>questions?</h1>
      </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
